# 计算器

- 该任务是可选的

- 任务

  实现可以进行括号运算的高级计算器，请利用栈的功能，可以使用中缀或后缀表达式;

  当然，你也可以采用BNF表达式进行递归求值。

- 附加任务：如何测试你的代码

  你将来是要使用你自己实现的表达式求值功能来帮助你来进行后续的调试的, 这意味着程序设计课上那种"代码随便测试一下就交上去然后就可以撒手不管"的日子已经一去不复返了. 测试需要测试用例, 通过越多测试, 你就会对代码越有信心. 但如果让你来设计测试用例, 设计十几个你就会觉得没意思了, 有没有一种方法来自动产生测试用例呢?

  一种常用的方法是[随机测试](https://en.wikipedia.org/wiki/Random_testing). 首先我们需要来思考如何随机生成一个合法的表达式. 事实上, 表达式生成比表达式求值要容易得多. 同样是上面的BNF, 我们可以很容易写出生成表达式的框架:

  ```C
  void gen_rand_expr() {
    switch (choose(3)) {
      case 0: gen_num(); break;
      case 1: gen('('); gen_rand_expr(); gen(')'); break;
      default: gen_rand_expr(); gen_rand_op(); gen_rand_expr(); break;
    }
  }
  ```

  你应该一眼就能明白上述代码是如何工作的: 其中`uint32_t choose(uint32_t n)`是一个很简单又很重要的函数, 它的作用是生成一个小于`n`的随机数, 所有随机生成的内容几乎都是通过它来选择的.

  有了这些随机表达式作为测试输入, 我们怎么知道输出对不对呢? 如果要我们把这些表达式手动算一遍, 那就太麻烦了. 如果可以在生成这些表达式的同时, 也能生成它们的结果, 这样我们就能得到类似OJ的测试用例啦! 我们需要一种满足以下条件的"计算器":

  - 进行的都是无符号运算
  - 数据宽度都是32bit
  - 溢出后不处理

  嘿! 如果我们把这些表达式塞到如下C程序的源文件里面:

  ```C
  #include <stdio.h>
  int main() {
    unsigned result = ???; // 把???替换成表达式printf("%u", <expression>);
    return 0;
  }
  ```

  然后用gcc编译它并执行, 让它输出表达式的结果, 这不就是我们想要的"计算器"吗?

  还真能这样做!

  不过实现的时候, 你很快就会发现需要面对一些细节的问题:

  - 如何保证表达式进行无符号运算?
  - 如何随机插入空格?
  - 如何生成长表达式, 同时不会使`buffer`溢出?
  - 如何过滤求值过程中有除0行为的表达式?

  这些问题大多都和C语言相关, 就当作是C语言的又一个编程练习吧

- 任务提示

  - BNF表达式（递归解法）

    把待求值表达式中的token都成功识别出来之后, 接下来我们就可以进行求值了. 需要注意的是, 我们现在是在对tokens数组进行处理, 为了方便叙述, 我们称它为"token表达式". 例如待求值表达式

    ```Plaintext
    "4 +3*(2- 1)"
    ```

    的token表达式为

    ```Plaintext
    +-----+-----+-----+-----+-----+-----+-----+-----+-----+
    | NUM | '+' | NUM | '*' | '(' | NUM | '-' | NUM | ')' |
    | "4" |     | "3" |     |     | "2" |     | "1" |     |
    +-----+-----+-----+-----+-----+-----+-----+-----+-----+
    ```

    根据表达式的归纳定义特性, 我们可以很方便地使用递归来进行求值. 首先我们给出算术表达式的归纳定义:

    ```Plaintext
    <expr> ::= <number>    # 一个数是表达式
      | "(" <expr> ")"     # 在表达式两边加个括号也是表达式
      | <expr> "+" <expr>  # 两个表达式相加也是表达式
      | <expr> "-" <expr>  # 接下来你全懂了
      | <expr> "*" <expr>
      | <expr> "/" <expr>
    ```

    上面这种表示方法就是大名鼎鼎的[BNF](http://en.wikipedia.org/wiki/Backus–Naur_Form), 任何一本正规的程序设计语言教程都会使用BNF来给出这种程序设计语言的语法.

    根据上述BNF定义, 一种解决方案已经逐渐成型了: 既然长表达式是由短表达式构成的, 我们就先对短表达式求值, 然后再对长表达式求值. 这种十分自然的解决方案就是[分治法](http://en.wikipedia.org/wiki/Divide_and_conquer_algorithms)的应用, 就算你没听过这个高大上的名词, 也不难理解这种思路. 而要实现这种解决方案, 递归是你的不二选择.

    为了在token表达式中指示一个子表达式, 我们可以使用两个整数`p`和`q`来指示这个子表达式的开始位置和结束位置. 这样我们就可以很容易把求值函数的框架写出来了:

    ```Plaintext
    eval(p, q) {
      if (p > q) {
        /* Bad expression */
      }
      else if (p == q) {
        /* Single token.
         * For now this token should be a number.
         * Return the value of the number.
         */
      }
      else if (check_parentheses(p, q) == true) {
        /* The expression is surrounded by a matched pair of parentheses.
         * If that is the case, just throw away the parentheses.
         */return eval(p + 1, q - 1);
      }
      else {
        /* We should do more things here. */
      }
    }
    ```

    其中`check_parentheses()`函数用于判断表达式是否被一对匹配的括号包围着, 同时检查表达式的左右括号是否匹配, 如果不匹配, 这个表达式肯定是不符合语法的, 也就不需要继续进行求值了. 我们举一些例子来说明`check_parentheses()`函数的 功能:

    ```Plaintext
    "(2 - 1)"             // true
    "(4 + 3 * (2 - 1))"   // true
    "4 + 3 * (2 - 1)"     // false, the whole expression is not surrounded by a matched
                          // pair of parentheses
    "(4 + 3)) * ((2 - 1)" // false, bad expression
    "(4 + 3) * (2 - 1)"   // false, the leftmost '(' and the rightmost ')' are not matched
    ```

    至于怎么检查左右括号是否匹配, 就当作一个程序设计作业, 留给聪明的你来思考吧!

    上面的框架已经考虑了BNF中算术表达式的开头两种定义, 接下来我们来考虑剩下的情况(即上述伪代码中最后一个`else`中的内容). 一个问题是, 给出一个最左边和最右边不同时是括号的长表达式, 我们要怎么正确地将它分裂成两个子表达式? 我们定义"主运算符"为表达式人工求值时, 最后一步进行运行的运算符, 它指示了表达式的类型(例如当一个表达式的最后一步是减法运算时, 它本质上是一个减法表达式). 要正确地对一个长表达式进行分裂, 就是要找到它的主运算符. 我们继续使用上面的例子来探讨这个问题:

    ```Plaintext
    "4 + 3 * ( 2 - 1 )"
    /*********************/
    case 1:
        "+"
       /   \
    "4"     "3 * ( 2 - 1 )"


    case 2:
            "*"
           /   \
    "4 + 3"     "( 2 - 1 )"


    case 3:
                  "-"
                 /   \
    "4 + 3 * ( 2"     "1 )"
    ```

    上面列出了3种可能的分裂, 注意到我们不可能在非运算符的token处进行分裂, 否则分裂得到的结果均不是合法的表达式. 根据主运算符的定义, 我们很容易发现, 只有第一种分裂才是正确的. 这其实也符合我们人工求值的过程: 先算`4`和`3 * ( 2 - 1 )`, 最后把它们的结果相加. 第二种分裂违反了算术运算的优先级, 它会导致加法比乘法更早进行. 第三种分裂破坏了括号的平衡, 分裂得到的结果均不是合法的表达式.

    通过上面这个简单的例子, 我们就可以总结出如何在一个token表达式中寻找主运算符了:

    - 非运算符的token不是主运算符.
    - 出现在一对括号中的token不是主运算符. 注意到这里不会出现有括号包围整个表达式的情况, 因为这种情况已经在`check_parentheses()`相应的`if`块中被处理了.
    - 主运算符的优先级在表达式中是最低的. 这是因为主运算符是最后一步才进行的运算符.
    - 当有多个运算符的优先级都是最低时, 根据结合性, 最后被结合的运算符才是主运算符. 一个例子是`1 + 2 + 3`, 它的主运算符应该是右边的`+`.

    要找出主运算符, 只需要将token表达式全部扫描一遍, 就可以按照上述方法唯一确定主运算符.

    找到了正确的主运算符之后, 事情就变得很简单了: 先对分裂出来的两个子表达式进行递归求值, 然后再根据主运算符的类型对两个子表达式的值进行运算即可. 于是完整的求值函数如下:

    ```Plaintext
    eval(p, q) {
      if (p > q) {
        /* Bad expression */
      }
      else if (p == q) {
        /* Single token.
         * For now this token should be a number.
         * Return the value of the number.
         */
      }
      else if (check_parentheses(p, q) == true) {
        /* The expression is surrounded by a matched pair of parentheses.
         * If that is the case, just throw away the parentheses.
         */return eval(p + 1, q - 1);
      }
      else {
        op = the position of 主运算符 in the token expression;
        val1 = eval(p, op - 1);
        val2 = eval(op + 1, q);

        switch (op_type) {
          case '+': return val1 + val2;
          case '-': /* ... */case '*': /* ... */case '/': /* ... */default: assert(0);
        }
      }
    }
    ```

    需要注意的是, 上述框架中并没有进行错误处理, 在求值过程中发现表达式不合法的时候, 应该给上层函数返回一个表示出错的标识, 告诉上层函数"求值的结果是无效的". 例如在`check_parentheses()`函数中, `(4 + 3)) * ((2 - 1)`和`(4 + 3) * (2 - 1)`这两个表达式虽然都返回`false`, 因为前一种情况是表达式不合法, 是没有办法成功进行求值的; 而后一种情况是一个合法的表达式, 是可以成功求值的, 只不过它的形式不属于BNF中的`"(" <expr> ")"`, 需要使用主运算符的方式进行处理, 因此你还需要想办法把它们区别开来. 当然, 你也可以在发现非法表达式的时候使用`assert(0)`终止程序. 不过这样的话, 你在使用表达式求值功能的时候就要十分谨慎了.

    最后, 为了方便统一, 我们认为所有结果都是`uint32_t`类型.

  - 栈的方式实现

    栈：是一种思想，实现将数据以先进后出（FILO）方式操作

      1模型

      2数据类型：

    ```C
    //宏：
    #define MAXSIZE  10
    //重命名：将int取一个别名：StackType
    typedef int StackType;
    //栈的类型：
    struct stack
    {
    //数据：
            StackType buf[6];       //栈的元素
    //方法
            short top;              //栈顶下标
    };
    ```

      3功能：

    ​    1、初始化：InitStack

    ​    2、清空栈：ClearStack

    ​    3、出栈：pop

    ​    4、进栈：push

    ​    5、判断栈为满：IsFull

    ​    6、判断栈为空：IsEmpty

    ​    7、取次栈顶

    ​    8、栈的元素个数：StackLength

    栈的应用：撤消与恢复，记忆，递归，“高级功能计算”

       高级功能计算器：

    ​     1.中缀表达式  数据 运算符 数据

    ​        （优点：直观的去表达一个表达式，缺点：不能直观的去表现优先级）

    ​            eg: 1+(2+3*4)-5

    ​     2、后缀：数据 数据 运算符

    ​        （缺点：不能直观表达式一个式子  优点：直观表达式优先级）

    ​          中缀转后缀规则：

    ​            1、从左往右遍历

    ​            2、如果是数据，则成为后缀表达式一部分

    ​            3、是运算则判断与栈顶的优先级：

    ​                1、如果是左括号，则直接进栈

    ​                2、如果是右括号，则一直出栈，直到遇到第一个左括号为止。

    ​                3、如果比栈顶的元素的优先级高，则直接进栈。

    ​                4、如果比栈顶元素的优先级低，则一直出栈，直到遇到比它低运算符为止。

    ​            4、重复1-3步骤，直到表达式遍历完成。

    ​           eg：1 2 3 4 * +  + 5 -

    ​     3、后缀进行计算：

    ​            eg:   1 2 3 4 * + + 5 -

    ​            规则：

    ​                1、从左往右遍历

    ​                2、如果遇到数字则进栈，否则取出栈顶和次栈顶进行运算。运算的结果要进栈

    ​                    （栈顶元素：操作数   次栈顶：被操作数 表达式： 被操作数  运算符  操作数）

    ​                3、重复1-2步骤，直到遍历完成。

- 附加功能模块：

  1. 在上述实现中, 我们并没有考虑负数的问题, 例如

     它们会被判定为不合法的表达式. 为了实现负数的功能, 你需要考虑两个问题:

     1. 负号和减号都是`-`, 如何区分它们?
     2. 负号是个单目运算符, 分类的时候需要注意什么?

  2. 如果生成的表达式有除0行为, 你编写的表达式生成器的行为又会怎么样呢?
